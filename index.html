<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
	<meta name="renderer" content="webkit"/>
	<title>模块化js库</title>
	<link href="/linsk1998/ting/master/ting/ting-quirks.css" rel="stylesheet"/>
	<link href="/linsk1998/ting/master/theme/bootstrap/indigo.css" rel="stylesheet"/>
</head>
<body>
	<div class="container">
		<h1>本项目是模块化js库</h1>
		<h3>基本概述</h3>
		<p></p>
		<h3>§ 1 基本用法</h3>
		<p>就是AMD用法</p>
		<p>在a.js中定义</p>
		<pre><code>define(function(){
	return "哈哈哈";
});</code></pre>
<p>调用时</p>
<pre><code>require(['a'],function(a){
	alert(a);
});</code></pre>
		<p><a href="AMD.html">示例</a></p>
		<h3>§ 2 CommonJS 容器</h3>
		<p>由于nodejs的流行，sea.js把CommonJS的习惯带到浏览器，叫做CMD。我这里也支持这种方式。</p>
		<pre><code>define(function(require, exports, module){
	// The module code goes here
});</code></pre>
		<div class="alert alert-warning">
			注意：该包装方法依靠Function.prototype.toString()，然后查找函数里的require的参数。
		</div>
		<p><a href="CMD.html">示例</a></p>
		<h3>§ 3 定义一个命名模块</h3>
		<p>这些常由优化工具生成。你也可以自己显式指定模块名称。</p>
		<pre><code>define("myName",[],function(){
	// The module code goes here
});</code></pre>
		<p><a href="name.html">示例</a></p>
		<h3>§ 4 JSONP</h3>
		<p>JSONP是在javascript中服务调用的一种方式。它仅需简单地通过一个script标签发起HTTP GET请求，是实现跨域服务调用一种公认手段。</p>
		<pre><code>require(["http://example.com/api/data.json?callback=define"],function(data){
	//....
});</code></pre>
		<p><a href="jsonp.html">示例</a></p>
		<h3>§ 5 多版本支持</h3>
		<p>本工具的配置非常灵活，在何种情况使用哪个地址是可以自行规定的。</p>
		<p><a href="jQuery.html">示例</a></p>
		<h2>上面都是通用的功能，下面就是我特有的功能了</h2>
		<h3>§ 6 依赖同名模块</h3>
		<pre><code>define('Cat',[],function(){
	//...
});
define('Cat',['Cat'],function(Cat){
	//...这里可以对原来的类修改
	return Cat;
});</code></pre>
		<p><a href="override.html">示例</a></p>
		<h3>§ 7 延迟初始化</h3>
		<p>实现必须异步才能初始化完成的类。</p>
		<pre><code>define('demo/delay',[],function(){
	this.delay(function(resolve, reject){
		setTimeout(function(){
			resolve('200 OK');
		},2000);
	});
});</code></pre>
		<p><a href="delay.html">示例</a></p>
		<h3>§ 8 合并文件</h3>
		<p>比如animal.js里定义了Dog类和Cat类</p>
		<pre><code>define('animal/mammal/Cat',[],function(){
	//...
});
define('animal/mammal/Dog',[],function(){
	//...
});</code></pre>
		<p>在加载时，我可以灵活配置什么模块加载哪个文件，所以可以配置让这两个模块都加载animal.js</p>
		<p><a href="bundle.html">示例</a></p>
		<h3>§ 9 加载包</h3>
		<p>按需加载有时候文件会加载过多，打包加载会一口气加载很多没有用到的类。为了实现按需加载和打包加载相结合，我可以进行一些灵活的配置，实现下面的功能。</p>
		<pre><code>//加载animal/mammal/Cat.js
require(['animal/mammal/Cat'],function(Cat){
	var cat=new Cat();
	cat.say();
});
//加载animal.js
require(['animal'],function(animal){
	var dog=new animal.mammal.Dog();
	dog.say();
});
//不会加载js
require(['animal/insect/Bee'],function(Bee){
	var bee=new Bee();
	bee.say();
});</code></pre>
		<p><a href="package.html">示例</a></p>
		<h3>§ 10 通配符</h3>
		<p>在加载时，我可以灵活配置什么模块加载哪个文件，所以可以配置让“.”当做目录、让“.*”当做包。但是一般的打包工具都不是按照这样的命名规则打包的，所以需要自己打包。</p>
		<pre><code>//加载animal/mammal/Cat.js
require(['animal.mammal.Cat'],function(Cat){
	var cat=new Cat();
	cat.say();
});
//加载animal.js
require(['animal.*'],function(animal){
	var dog=new animal.mammal.Dog();
	dog.say();
});
//由于animal.js加载过了，不会再加载js了
require(['animal.insect.Bee'],function(Bee){
	var bee=new Bee();
	bee.say();
});</code></pre>
	</div>
</body>
</html>